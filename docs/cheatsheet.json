[
  {
    "name": "Hy",
    "categories": [
      {
        "name": "IO",
        "methods": [
          "hy.repr",
          "hy.repr-register",
          "hy.mangle",
          "hy.unmangle",
          "hy.read",
          "hy.read-str"
        ]
      },
      {
        "name": "Reader",
        "methods": [
          "hy.eval",
          "hy.gensym",
          "hy.macroexpand",
          "hy.macroexpand-1",
          "hy.disassemble"
        ]
      }
    ]
  },
  {
    "name": "Core",
    "categories": [
      {
        "name": "Collections",
        "methods": [
          "hy.core.language.butlast",
          "hy.core.language.distinct",
          "hy.core.language.drop-last",
          "hy.core.language.flatten",
          "hy.core.language.rest",
          "hy.core.language.some"
        ]
      },
      {
        "name": "Functions",
        "methods": ["hy.core.language.constantly"]
      },
      {
        "name": "Tests",
        "methods": [
          "hy.core.language.pos?",
          "hy.core.language.coll?",
          "hy.core.language.integer?",
          "hy.core.language.integer-char?",
          "hy.core.language.iterable?",
          "hy.core.language.keyword?",
          "hy.core.language.list?",
          "hy.core.language.iterator?",
          "hy.core.language.empty?",
          "hy.core.language.even?",
          "hy.core.language.every?",
          "hy.core.language.float?",
          "hy.core.language.neg?",
          "hy.core.language.none?",
          "hy.core.language.numeric?",
          "hy.core.language.odd?",
          "hy.core.language.tuple?",
          "hy.core.language.string?",
          "hy.core.language.symbol?",
          "hy.core.language.zero?"
        ]
      },
      {
        "name": "Meta",
        "methods": [
          "hy.core.macros.defmacro/g!",
          "hy.core.macros.defmacro!",
          "hy.core.macros.comment",
          "hy.core.macros.doc",
          "hy.core.language.calling-module",
          "hy.core.language.calling-module-name",
          "hy.core.language.parse-args"
        ]
      },
      {
        "name": "Macros",
        "methods": [
          "hy.core.macros.as->",
          "hy.core.macros.->",
          "hy.core.macros.->>",
          "hy.core.macros.cfor",
          "hy.core.macros.doto",
          "hy.core.macros.of",
          "hy.core.macros.when",
          "hy.core.macros.if-not",
          "hy.core.macros.lif",
          "hy.core.macros.lif-not",
          "hy.core.macros.cond",
          "hy.core.macros.unless",
          "hy.core.macros.with-gensyms",
          "hy.core.macros.defmain"
        ]
      },
      {
        "name": "Special Forms",
        "methods": [
          "^",
          {
            "name": "\\.",
            "uri": "dot",
            "internal": true
          },
          "annotate",
          "fn",
          "fn/a",
          "defn",
          "defn/a",
          "defmacro",
          "if",
          "assert",
          "get",
          "global",
          "import",
          "eval-and-compile",
          "eval-when-compile",
          "await",
          "break",
          "chainc",
          "continue",
          "do",
          "for",
          "lfor",
          "dfor",
          "gfor",
          "sfor",
          "setv",
          "setx",
          "defclass",
          "del",
          "nonlocal",
          "py",
          "pys",
          "quasiquote",
          "quote",
          "require",
          "return",
          "cut",
          "raise",
          "try",
          "unpack-iterable/unpack-mapping",
          "unquote",
          "unquote-splice",
          "while",
          "with",
          "with/a",
          "with-decorator",
          "yield",
          "yield-from"
        ]
      },
      {
        "name": "Arithmetic",
        "methods": [
          "hy.core.language.dec",
          "hy.core.shadow.@",
          "hy.core.shadow.%",
          "hy.core.shadow.+",
          "hy.core.shadow.-",
          "hy.core.shadow.*",
          "hy.core.shadow.**",
          "hy.core.shadow./",
          "hy.core.shadow.//",
          "hy.core.language.inc"
        ]
      },
      {
        "name": "Dicts",
        "methods": ["hy.core.macros.assoc"]
      },
      {
        "name": "Comparison",
        "methods": [
          "hy.core.macros.cond",
          "hy.core.shadow.<",
          "hy.core.shadow.>",
          "hy.core.shadow.<=",
          "hy.core.shadow.>=",
          "hy.core.shadow.=",
          "hy.core.shadow.\\!=",
          "hy.core.shadow.is",
          "hy.core.shadow.not?",
          "hy.core.shadow.in",
          "hy.core.shadow.not-in"
        ]
      },
      {
        "name": "Bitwise",
        "methods": [
          "hy.core.shadow.\\<\\<",
          "hy.core.shadow.>>",
          "hy.core.shadow.&",
          "hy.core.shadow.|",
          "hy.core.shadow.^",
          "hy.core.shadow.~"
        ]
      },
      {
        "name": "Logic",
        "methods": [
          "hy.core.language.xor",
          "hy.core.shadow.not",
          "hy.core.shadow.and",
          "hy.core.shadow.or"
        ]
      }
    ]
  },
  {
    "name": "Extras",
    "categories": [
      {
        "name": "Anaphoric",
        "methods": [
          "hy.extra.anaphoric.ap-dotimes",
          "hy.extra.anaphoric.ap-each",
          "hy.extra.anaphoric.ap-each-while",
          "hy.extra.anaphoric.ap-filter",
          "hy.extra.anaphoric.ap-first",
          "hy.extra.anaphoric.ap-if",
          "hy.extra.anaphoric.ap-last",
          "hy.extra.anaphoric.ap-map",
          "hy.extra.anaphoric.ap-map-when",
          "hy.extra.anaphoric.ap-reduce",
          "hy.extra.anaphoric.ap-reject",
          "hy.extra.anaphoric.recur-sym-replace",
          "hy.extra.anaphoric.rit"
        ]
      },
      {
        "name": "Reserved",
        "methods": ["hy.extra.reserved.names"]
      }
    ]
  },
  {
    "name": "Contributor",
    "categories": [
      {
        "name": "Sequences",
        "methods": [
          "hy.contrib.sequences.Sequence",
          "hy.contrib.sequences.defseq",
          "hy.contrib.sequences.end-sequence",
          "hy.contrib.sequences.seq"
        ]
      },
      {
        "name": "Walk",
        "methods": [
          "hy.contrib.walk.call?",
          "hy.contrib.walk.lambda-list",
          "hy.contrib.walk.let",
          "hy.contrib.walk.macroexpand-all",
          "hy.contrib.walk.postwalk",
          "hy.contrib.walk.prewalk",
          "hy.contrib.walk.smacrolet",
          "hy.contrib.walk.walk"
        ]
      },
      {
        "name": "Profile",
        "methods": [
          "hy.contrib.profile.profile/calls",
          "hy.contrib.profile.profile/cpu"
        ]
      },
      {
        "name": "Loop",
        "methods": ["hy.contrib.loop.loop"]
      },
      {
        "name": "PPrint",
        "methods": [
          "hy.contrib.pprint.PrettyPrinter",
          "hy.contrib.pprint.pformat",
          "hy.contrib.pprint.pprint",
          "hy.contrib.pprint.readable?",
          "hy.contrib.pprint.recursive?",
          "hy.contrib.pprint.saferepr",
          "hy.contrib.pprint.pp"
        ]
      },
      {
        "name": "Destructure",
        "methods": [
          "hy.contrib.destructure.defn+",
          "hy.contrib.destructure.fn+",
          "hy.contrib.destructure.defn/a+",
          "hy.contrib.destructure.fn/a+",
          "hy.contrib.destructure.setv+",
          "hy.contrib.destructure.let+",
          "hy.contrib.destructure.ifp",
          "hy.contrib.destructure.dict=:",
          "hy.contrib.destructure.destructure"
        ]
      },
      {
        "name": "Slicing",
        "methods": ["hy.contrib.slicing.ncut", "hy.contrib.slicing.#:"]
      }
    ]
  }
]
